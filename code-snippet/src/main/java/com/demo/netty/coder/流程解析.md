# 流程解析

启动服务端 -> 启动客户端  
客户端打印的结果
```text
[2020-03-27T11:50:28.696]进入编码器
[2020-03-27T11:50:28.696]编码消息为 : 123456
[2020-03-27T11:50:28.742]进入解码器
[2020-03-27T11:50:28.743]解码后的消息为 : 98765
[2020-03-27T11:50:28.743]客户端接收到消息 : 98765
```

服务端打印的结果
```text
[2020-03-27T11:50:28.733]进入解码器
[2020-03-27T11:50:28.736]解码后的消息为 : 123456
[2020-03-27T11:50:28.737]服务器接收到消息 : 123456
[2020-03-27T11:50:28.737]进入编码器
[2020-03-27T11:50:28.737]编码消息为 : 98765
```
流程分析:
1. 客户端启动
2. 触发`CoderClientHandler`的`channelActive()`方法,发送消息`123456L`
3. 发送消息后进入编码器`TestLongEncoder`,将Long数据编译成ByteBuf类型.所以输出结果
    ```text
    [2020-03-27T11:50:28.696]进入编码器
    [2020-03-27T11:50:28.696]编码消息为 : 123456
    ```
   从时间上看也能看到他是最先执行的
 4. 数据到达服务端,解码器`TestLongDecoder`,所以输出结果为
    ```text
    [2020-03-27T11:50:28.733]进入解码器
    [2020-03-27T11:50:28.736]解码后的消息为 : 123456
    ```
 5. 消息解码之后到达处理器`LongEncoderHandler`,输出结果为
    `[2020-03-27T11:50:28.737]服务器接收到消息 : 123456,服务器接收到消息后返回消息`ctx.writeAndFlush(98765L);`
 6. 服务器发送消息后,又经过编码器`TestLongEncoder`,可以看到输出结果为
   ```text
    [2020-03-27T11:50:28.737]进入编码器
    [2020-03-27T11:50:28.737]编码消息为 : 98765
   ```
7. 返回消息到达客户端,又需要进行解码,所以达到解码器`TestLongDecoder`打印出结果
    ```text
   [2020-03-27T11:50:28.742]进入解码器
   [2020-03-27T11:50:28.743]解码后的消息为 : 98765
    ```
8. 最后返回的消息到达客户端的处理器`CoderClientHandler`,然后打印出结果
`[2020-03-27T11:50:28.743]客户端接收到消息 : 98765`

从上面可以看出整个流程的解析和输出结果一致